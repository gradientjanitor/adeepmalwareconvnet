# for the 2015 MICROSOFT KAGGLE MALWARE COMPETITION, the .bytes files
# consist of hexdumps (minus the PE header) of a bunch of malware.
# this is very wasteful of space.  this script takes the train
# and test sets and saves the to a tar file that we can iterate over
# later.

import sys
import glob
import gzip
import lmdb
import argparse
import binascii

def kaggle_to_ascii(filename):
    h = []

    # open this plaintext hexdump.
    for l in open(filename, "rb").readlines():
        # remove the hex addr; keep those sweet hex chars
        lb = b"".join(l.split()[1:])
        h.append(lb)

    h = b"".join(h)

    # why are there question marks in a hexdump???
    h = h.replace(b"?", b"")

    # turn the hex into bytes. return.
    return binascii.a2b_hex(h)


parser = argparse.ArgumentParser(description='Put kaggle data back into something thats fast to read.')
parser.add_argument('path', type=str, help='path to data')
args = parser.parse_args()

path = args.path

# open an lmdb with a max sz of 60gb
env = lmdb.open('malware_data', map_size=60*2**30)

# write our data out to the lmdb
for phase in ["train", "test"]:
    filenames = glob.glob(path + "/" + phase + "/*.bytes")
    for nf, filename in enumerate(filenames):
        print(nf / len(filenames))
        uid = filename.split("/")[-1].split(".")[0]
        sample_bytes = kaggle_to_ascii(filename)

        with env.begin(write=True) as txn:
            txn.put(uid.encode(), sample_bytes)
